# 安卓日记

## changeImage

```
问题一：使用random创建随机数随机摆放数字，可是random随机数的重复率太高了，导致加载失败，显示白屏
 int num = random.nextInt(15);
                while(cardFlag[num]!=0){
                    num = random.nextInt(15);
                    Log.v("random",num+"");
                }
```

记住Random创建随机数的范围是

``` java
int num = random.nextInt(16);
是不包括16的 从0到15 【0，16）  不然又产生死机，陷入死循环
定义方法实现
      private void setCardsnums(){
        cardFlag = new int[16];
        long seed1 = System.nanoTime();
        Random random = new Random(seed1);
        int[] cardnums = new int[16];
        for(int i=0;i<16;i++){
            int num = random.nextInt(16);
            while(cardnums[num]!=0){
                    num = random.nextInt(16);
                }
            cardnums[num]++;
            cardFlag[i]= num;
            Log.v("random",num+"");
        }
    }
```

![image-20211219160936891](D:\Typoramarkdown学习编辑\img\image-20211219160936891.png)

![image-20211219160952825](D:\Typoramarkdown学习编辑\img\image-20211219160952825.png)







#### if判断 条件逻辑

```java
 private boolean checkComplete(){
        for(int x = 0 ;x<Row; x++){
            for(int y = 0 ;y<Col;y++){
                if((x!=Row-1)&&(y!=Col-1)){
                    if(cardsMap[x][y].getNum() != (x*Col+y+1)){
                        Log.v("masd"+x + " "+ y,cardsMap[x][y].getNum()+"");
                        return false;
                    }
                }
            }
      }
     LoadingDialog.LDialog(MainActivity.getMainActivity());
//        startGame();
        return true;
  }
```

#### dialog

设置自定义dialog的窗口大小，需要在dialog.show() 方法之后再设置大小。

```java
dialog.show();
Display d = m.getDefaultDisplay(); // 获取屏幕宽、高用
WindowManager.LayoutParams p = dialogWindow.getAttributes(); // 获取对话框当前的参数值
p.height = (int) (d.getHeight() * 0.4); // 高度设置为屏幕的0.6
p.width = (int) (d.getWidth() * 0.4); // 宽度设置为屏幕的0.65

dialog.getWindow().setAttributes(p);//设置大小
```

#### img bitmap 坐标问题

![捕获](D:\Typoramarkdown学习编辑\img\捕获.PNG)

```
 Log.e("TAG", "bitmap Width = " + width + " , height = " + height);
        int after_width = Math.min(width,height);
        int startx=0,starty=0;
        if(after_width == width){
            starty = (height- width)/2;
            startx = 0;
        }else if(after_width == height){
            startx = (width - height)/2;
            starty = 0;
        }
        //x he y buyaogaofanle!!!!11
        int pieceWidth = width / Col;
//        int pieceHeight = height / Row;
        bitmap = Bitmap.createBitmap(bitmap,startx,starty,after_width,after_width);
```

#### menu问题

在数字拼图模块中，需要显示菜单，实现图片拼图模块的图片的自由选择。

给imgActivity一直定义的为继承activity 结果menu 一直不显示，无法响应 ，

解决方法：需要在  AppCompatActivity  类 中重写方法实现，并且采用默认的主题

但在2048 中没有使用  AppCompatActivity  就可以显示菜单，



#### 关于拼图碎片的确认问题

- 实现一：

  将检查是否结束的方法修改为每次确认，并修改每个碎片的透明度实现是否正确的提示，若位置正确，将透明度修改为180（0-255） 并且为了避免出现问题，在startGame() 方法中 在初始化时 将透明度再次修改。

- 实现二：

  点击碎片 跳出Toast提示，显示当前碎片的应属位置。

## app开发

### 一、主要功能

#### 1小游戏 

#### 2心情治愈，时间定时功能

#### 3设计目标

集合游戏和记录心情笔记的应用

一定要操作灵活使用

数据存储问题，未知

#### 4设计步骤

产品分析，需求分析

ui设计 （ fragrament acitivity    xml）

①项目启动

产品总监确定产品或者项目的方向，简单点说就是我们要做一个什么东西，然后产品经理做相关市场调研，把业务梳理清楚，再交给产品总监审核。

在这个阶段要确定的是我们要做一个什么产品，该产品包含了哪些业务功能、业务逻辑、业务配置。产出是PRD文档。

②产品需求

产品经理根据第一阶段产出的业务逻辑做出产品原型图，交于UI设计师、开发工程师，开评审会，UI设计师和开发总监评审业务功能、评估完成难度与时间。产出是产品原型图。

③设计阶段

主要是UI设计师根据产品原型设计UI界面、UI标注、UI设计规范，开发总监基于效果图，明确业务实现细节，消除对最终成果理解的不一致。产出是UI设计图、标注图等。

④开发阶段

开发总监给各个工程师(后端、前端、App端)分配对象开发任务，产出是产品。

⑤测试阶段

专业的测试人员、产品经理、产品总监、老板，都是产品的测试人员，这个阶段最难过，会听到不同的人说不同的话，好听的难听的好好听着就行。产出是测试用例以及测试结果。

⑥产品上线

### 二、主要详细功能分工设计

进入主界面，左右滑动设计，选择游戏和记录

游戏选择 （界面一定要灵活）尽量选择图片或者滑动操作，可增加体验流畅感

日记记录：

- 心情选择
- 编写内容
- 查看内容列表
- 底部导航栏，具体实现多功能操作的切换
- 计时器，情绪的记录时间，持续时间，可生成记录，图表







### 三、界面主题

##### 1.计时器

<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-25-22-58-50-79_8e6c63e79bcf69c.jpg" alt="Screenshot_2021-12-25-22-58-50-79_8e6c63e79bcf69c" style="zoom: 33%;" />

手动滑动，设定时间，并且有震动效果，体验感觉更加真实

计时器设计美观

<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-25-23-03-53-44_32d22f3432090b7.jpg" alt="Screenshot_2021-12-25-23-03-53-44_32d22f3432090b7" style="zoom: 33%;" />

首页时钟展示

<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-25-22-56-20-83_c6202e8d53caa39.jpg" alt="Screenshot_2021-12-25-23-12-09-56_60b01be59ae1fee" style="zoom:25%;" />

计时器，透明背景，美观，并且可自定义修改背景主题



<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-25-22-56-46-11_c6202e8d53caa39.jpg" alt="Screenshot_2021-12-25-22-56-46-11_c6202e8d53caa39" style="zoom:25%;" /><img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-25-22-57-26-29_c6202e8d53caa39.jpg" alt="Screenshot_2021-12-25-22-57-26-29_c6202e8d53caa39" style="zoom:25%;" /><img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-25-22-56-53-35_c6202e8d53caa39.jpg" alt="Screenshot_2021-12-25-22-57-21-06_c6202e8d53caa39" style="zoom: 25%;" />

天气展示功能，其权限访问功能，需要访问地址，相关天气数据不知道该如何获得

<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-00-05-41-93_7d2d1506325693b.jpg" alt="Screenshot_2021-12-26-00-05-41-93_7d2d1506325693b" style="zoom:25%;" /><img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-00-05-19-70_7d2d1506325693b.jpg" alt="Screenshot_2021-12-26-00-05-19-70_7d2d1506325693b" style="zoom:25%;" /><img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-00-05-22-97_7d2d1506325693b.jpg" alt="Screenshot_2021-12-26-00-05-22-97_7d2d1506325693b" style="zoom:25%;" /><img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-00-05-16-25_7d2d1506325693b.jpg" alt="Screenshot_2021-12-26-00-05-16-25_7d2d1506325693b" style="zoom: 25%;" />

##### 2.日记便签

<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-25-22-59-42-67_8e6c63e79bcf69c.jpg" alt="Screenshot_2021-12-25-22-59-42-67_8e6c63e79bcf69c" style="zoom: 25%;" /><img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-25-22-59-12-18_8e6c63e79bcf69c.jpg" alt="Screenshot_2021-12-25-22-59-12-18_8e6c63e79bcf69c" style="zoom:25%;" /><img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-25-22-59-58-25_8e6c63e79bcf69c.jpg" alt="Screenshot_2021-12-25-22-59-58-25_8e6c63e79bcf69c" style="zoom: 25%;" /><img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-25-23-00-04-30_8e6c63e79bcf69c.jpg" alt="Screenshot_2021-12-25-23-00-04-30_8e6c63e79bcf69c" style="zoom: 25%;" />

可自己调整计时器的提醒颜色

<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-25-23-05-13-20_0e1330587da2dd1-16404481983841.jpg" alt="Screenshot_2021-12-25-23-05-13-20_0e1330587da2dd1" style="zoom:25%;" />

页面展示有语句推送

<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-25-23-17-45-33_fba10279d5e1c96.jpg" alt="Screenshot_2021-12-25-23-17-45-33_fba10279d5e1c96" style="zoom:25%;" />

添加功能明确，主题美观，可操作性强

<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-00-07-27-34_79de53696d4c557.jpg" alt="Screenshot_2021-12-26-00-07-27-34_79de53696d4c557" style="zoom:33%;" />





<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-00-07-11-76_79de53696d4c557-16404485297493.jpg" alt="Screenshot_2021-12-26-00-07-11-76_79de53696d4c557" style="zoom:25%;" />

<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-00-06-58-49_6e02b97ec241f4c-16404485562714.jpg" alt="Screenshot_2021-12-26-00-06-58-49_6e02b97ec241f4c" style="zoom:25%;" /><img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-00-06-51-74_6e02b97ec241f4c.jpg" alt="Screenshot_2021-12-26-00-06-51-74_6e02b97ec241f4c" style="zoom:25%;" /><img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-00-06-26-90_6e02b97ec241f4c-16404486056776.jpg" alt="Screenshot_2021-12-26-00-06-26-90_6e02b97ec241f4c" style="zoom:25%;" />



<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-00-06-23-35_6e02b97ec241f4c.jpg" alt="Screenshot_2021-12-26-00-06-23-35_6e02b97ec241f4c" style="zoom:25%;" /><img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-00-06-07-28_6e02b97ec241f4c.jpg" alt="Screenshot_2021-12-26-00-06-07-28_6e02b97ec241f4c" style="zoom:25%;" /><img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-00-06-01-42_6e02b97ec241f4c-16404486635527.jpg" alt="Screenshot_2021-12-26-00-06-01-42_6e02b97ec241f4c" style="zoom:25%;" />

<img src="C:\Users\30997\Documents\Tencent Files\3099722528\FileRecv\MobileFile\Screenshot_2021-12-26-00-05-50-27_6e02b97ec241f4c.jpg" alt="Screenshot_2021-12-26-00-05-50-27_6e02b97ec241f4c" style="zoom:25%;" />











<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-21-17-05-27_ae1f93045b87aac.jpg" alt="Screenshot_2021-12-26-21-17-05-27_ae1f93045b87aac" style="zoom:25%;" />

点击＋按键，动画滑出界面

<img src="D:\Typoramarkdown学习编辑\img\Screenshot_2021-12-26-21-17-35-49_ae1f93045b87aac.jpg" alt="Screenshot_2021-12-26-21-17-35-49_ae1f93045b87aac" style="zoom:25%;" />

#### 四、开发步骤

## Myemo开发

#### 关于起始界面splash 实现的步骤

- 第一步创建acticity  编写线程

```java
import android.content.Intent;

import android.support.v7.app.AppCompatActivity;

import android.os.Bundle;

import android.view.WindowManager;

public class Splash extends AppCompatActivity {

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate( savedInstanceState);
    getWindow().addFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN);//隐藏状态栏
    getSupportActionBar().hide();//隐藏标题栏
    setContentView(R.layout.activity_splash);
    Thread myThread=new Thread(){//创建子线程
        @Override
        public void run() {
            try{
                sleep(5000);//使程序休眠五秒
                Intent it=new Intent(getApplicationContext(),MainActivity.class);//启动MainActivity
                startActivity(it);
                finish();//关闭当前活动
            }catch (Exception e){
                e.printStackTrace();
            }
        }
    };
    myThread.start();//启动线程
}
}

```

- 第二步编写界面文件

  即创建activity_splash.xml文件

- 第三步修改Manifest文件配置

  ```xml
  <activity
              android:name=".Splash.SplashActivity"
              android:exported="true">
              <intent-filter>
                  <action android:name="android.intent.action.MAIN" />
  
                  <category android:name="android.intent.category.LAUNCHER" />
              </intent-filter>
          </activity>
          <activity
              android:name=".MainActivity"
              android:exported="true">
              <intent-filter>
                  <action android:name="android.intent.action.SHOW_APP_INFO" />
  
                  <category android:name="android.intent.category.LAUNCHER" />
              </intent-filter>
          </activity>
  ```

  

- 实现结果为

  ![](D:\Typoramarkdown学习编辑\img\1-16435263323721.gif)

#### 关于程序添加配置出现错误

![image-20220118001046251](D:\Typoramarkdown学习编辑\img\image-20220118001046251.png)

![image-20220118001155002](D:\Typoramarkdown学习编辑\img\image-20220118001155002.png)

解决过程：

发现添加了相同的配置依赖，删除该依赖后，运行正常。

大概原因：两个依赖包含相同的包，产生了矛盾。





#### 关于mipmap的理解

**mipmap的定义——什么是mipmap**

***铺设和贴图，根据需要将图片按照比例加载为对应的大小层级***

在三维计算机图形的贴图渲染过程中有一个常用的技术被称为Mipmapping。为了加快渲染速度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件，这样的贴图被称为 MIP map 或者 mipmap。这个技术在三维游戏中被非常广泛的使用。“MIP”来自于拉丁语 multum in parvo 的首字母，意思是“放置很多东西的小空间”，而**mipmap中的map有铺设、贴图的意思。**

**Mipmap中每一个层级的小图都是主图的一个特定比例的缩小细节的复制品。虽然在某些必要的视角，主图仍然会被使用来渲染完整的细节。但是当贴图被缩小或者只需要从远距离观看时，mipmap就会转换到适当的层级**，此时mipmap贴图需要被读取的像素远少于普通贴图，所以渲染的速度得到了提升。而且操作的时间减少了，因为mipmap的图片已经是做过抗锯齿处理的，从而减少了实时渲染的负担。放大和缩小也因为mipmap而变得更有效率。

如果某张mipmap贴图的基本尺寸是256x256像素且长宽特定缩放比例为2，该mipmap贴图就会有8个层级。每个层级是上一层级的四分之一的大小，依次层级大小就是：128x128；64x64；32x32；16x16；8x8；4x4；2x2；1x1(一个像素)。  

#### 关于安卓动画分类

![image-20220125141533168](D:\Typoramarkdown学习编辑\img\image-20220125141533168.png)

#### SQLite 存储类

**每个存储在 SQLite 数据库中的值都具有以下存储类之一：**

**![img](https://img-blog.csdn.net/20180514110632766)
**

**安卓数据库的基本使用：**

**定义数据库帮助类：**

```java
//创建数据库帮助类 实现对数据库的创建修改编辑等操作
public class DatabaseHelper extends SQLiteOpenHelper {
        // 创建数据库 ，数据表 user log
    public static final  String Create_logtable = "create table user_log ("   + "logid integer primary key autoincrement, "
                + "log text,  "
                + "logtime  datetime,  " +  " styleid integer not null ) ";
    public static final String Create_styletable = "create table style( " + "styleid integer primary key autoincrement, "
            + "background text, " + " textcolor text )";
  public DatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory cursorFactory, int version)
    {
       super(context, name, cursorFactory, version);
       Log.v("Createdb","创建数据库成功！");
    }     
     
    @Override    
    public void onCreate(SQLiteDatabase db) {     
        // TODO 创建数据库后，对数据库的操作
//        创建日志表和 样式表
        db.execSQL(Create_logtable);
        db.execSQL(Create_styletable);
        Log.v("Createdb" ,"创建两个数据库表成功！");
    }     
     
    @Override    
public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {     
        // TODO 更改数据库版本的操作     
    }     
     
@Override    
public void onOpen(SQLiteDatabase db) {     
        super.onOpen(db);       
        // TODO 每次成功打开数据库后首先被执行     
    }
}     
```

**数据库帮助类的使用：**

在Activity中调用，当一次调用该类时，会创建数据库，数据库创建之后，再次调用该类时，数据库中的表再重新创建，只能删除模拟机中的相关文件，才能重新创建（文件路径一般为：data/data/+包名+/database）

```java
//数据库操作实例
    public void initDb(){
        // 创建数据库和表 调用该类，并调用cursor方法 实现查找数据
        DatabaseHelper dbhelper = new DatabaseHelper(LogActivity.this,"myemodb123.db",null,1);
        SQLiteDatabase db = dbhelper.getReadableDatabase();
        Cursor cursor = db.query("user_log",new String[]{"logid","log","logtime","styleid"},null,null,null,null,"logtime desc");
        userlogList = new ArrayList<Userlog>(); 
        if(cursor!=null && cursor.getCount()>0){
            while(cursor.moveToNext()){
              Userlog userlog;
              int logid = cursor.getInt(0);
              String logtext = cursor.getString(1);
              String logtime=  cursor.getString(2);
              int styleid = cursor.getInt(3);
              userlog = new Userlog(logid,logtext,logtime,styleid);
              userlogList.add(userlog);
//              Log.v("userloglist",userlog.toString()); 确保查到数据，输出查看
            }
        }else{
            Log.v("userloglist","当前查找loglist为空！");
        }
        cursor.close(); //切记要关闭，不然可能会造成内存指针异常
        db.close();
    }
```

数据库删除操作

```java
public void Delete_logALL(){
        if(userlogList.size()!=0){
            SQLiteDatabase db = dbhelper.getWritableDatabase();
            for(int i=0;i<userlogList.size();i++){
                int id = userlogList.get(i).getLogid();
                String sql = "delete from user_log where logid =  " + id ;
                db.execSQL(sql);
            }
            Log.v("Logli34vity","菜单加载失败");
            db.close();
        }else{
            Toast.makeText(LogActivity.this,"当前list为空",Toast.LENGTH_SHORT).show();
        }
     
    }
```



#### 关于finish（） ondestroy（）  onBackpressed()  onkeydown（）方法

1、调用onBackPressed()方法不一定就能结束Activity。

2、调用onBackPressed()方法结束Activity，其调用的终究还是finish()方法。

3、finish()方法最后调用了Ondestory。

4、Android系统内存紧张时，可能会关闭软件进程，此时Activity的该方法不一定必然被调用。

**finish（）**方法用于结束一个Activity的生命周期，而**onDestory()**方法则是Activity的一个生命周期方法，其作用是在一个Activity对象被销毁之前，Android系统会调用该方法，用于释放此Activity之前所占用的资源。

finish会调用到onDestroy方法，可以在onDestroy里打印一句话，就会发现在finish方法那也会打印这句话。

**Activity.finish()** 
在你的activity动作完成的时候，或者Activity需要关闭的时候，调用此方法。
当你调用此方法的时候，系统只是将最上面的Activity移出了栈，并没有及时的调用onDestory（）方法，其占用的资源也没有被及时释放。因为移出了栈，所以当你点击手机上面的“back”按键的时候，也不会再找到这个Activity。
**Activity.onDestory()** 
系统销毁了这个Activity的实例在内存中占据的空间。
在Activity的生命周期中，onDestory()方法是他生命的最后一步，资源空间等就被回收了。当重新进入此Activity的时候，必须重新创建，执行onCreate()方法。‍

**onkeyDown()**

onkeyDown()方法中 监听按键事件，以实现具体操作

实例：

```
  /**  上次点击返回键的时间  */
    private long lastBackPressed;
  /**  上次点击返回键的时间  */
    private static final int QUIT_INTERVAL = 3000;
    @Override
 @Override
    public boolean onKeyDown(int keyCode, KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN) {
            if (keyCode == KeyEvent.KEYCODE_BACK) { // 表示按返回键时的操作
                long backPressed = System.currentTimeMillis();      // 获取当前的时间
                if (backPressed - lastBackPressed > QUIT_INTERVAL) {
                    lastBackPressed = backPressed;
                    Toast.makeText(MainActivity.this, "再按一次退出", Toast.LENGTH_SHORT).show();
                } else {
                    moveTaskToBack(false);                                    // 结束任务 ,在这里可
                    finish();
                }
            }
        }
        return false;
    }
```

#### 关于自定义clockview

![image-20220129215441428](D:\Typoramarkdown学习编辑\img\image-20220129215441428.png)

具体实现方法：

1. 定义一个类继承View

2. 重写方法

   ```java
   public MyQAnalogColck2(Context context) {
       super(context);
   
   }
   
   public MyQAnalogColck2(Context context, @Nullable AttributeSet attrs) {
       super(context, attrs);
   
   }
   ```

   3.onDraw（） 

   ```java
   @Override
   protected void onDraw(Canvas canvas) {
       super.onDraw(canvas);
       Paint paint = new Paint();  // 定义画笔风格
       paint.setStyle(Paint.Style.STROKE);
       paint.setStrokeWidth(8);
       paint.setColor(Color.BLACK);
       setCenter(); //将画笔置于屏幕中心
       //画出时钟的外圆
       canvas.drawCircle(width, heigth, radius+10, paint);
   
       //画大刻度
       for (int i = 1; i < 13; i++) {
           canvas.save();//保存当前的状态
           //1:旋转的角度 2.旋转中心的X轴坐标 3.旋转中心的Y轴坐标
           canvas.rotate(i * 30, width, heigth);
           //画刻度线 相当于250,50,250,65
           canvas.drawLine(width, heigth - radius, width, heigth - radius + 15, paint);
           canvas.restore();//返回初始保存的状态
       } 
       //画小刻度
       for (int i = 0; i < 60; i++) {
           canvas.save();//保存当前的状态
           //1:旋转的角度 2.旋转中心的X轴坐标 3.旋转中心的Y轴坐标
           canvas.rotate(i * 6, width, heigth);
           //画刻度线 相当于250,50,250,55
           canvas.drawLine(width, heigth - radius, width, heigth - radius + 5, paint);
           canvas.restore();//返回初始保存的状态
       }
   
       //画钟表的心
       Paint centerPaint = new Paint();
       centerPaint.setColor(Color.RED);
       centerPaint.setStyle(Paint.Style.FILL);
       canvas.drawCircle(width, heigth, 10, centerPaint);
     // 修改画笔风格
       paint.setColor(Color.RED);
       paint.setTextSize(25);
       paint.setStrokeWidth(3);
   
       //写时间刻度
       for (int i = 1; i < 13; i++) {
           canvas.save();//保存当前的状态
           //1:旋转的角度 2.旋转中心的X轴坐标 3.旋转中心的Y轴坐标
           canvas.rotate(i * 30, width, heigth);
           //写数字 相当于250,50,250,65
           canvas.drawText(i + "", width - 5, heigth - radius + 50, paint);
           canvas.restore();//返回初始保存的状态
       }
   
   
       //时针画笔样式
       hourPaint = new Paint();
       hourPaint.setColor(Color.BLACK);
       hourPaint.setStyle(Paint.Style.FILL);
       hourPaint.setStrokeWidth(7);
   
       //分针画笔样式
       minPaint = new Paint();
       minPaint.setColor(Color.GRAY);
       minPaint.setStyle(Paint.Style.FILL);
       minPaint.setStrokeWidth(6);
   
       //秒针画笔样式
       secPaint = new Paint();
       secPaint.setColor(Color.BLUE);
       secPaint.setStyle(Paint.Style.FILL);
       secPaint.setStrokeWidth(4);
   
       //获取系统时间
       Calendar calendar = Calendar.getInstance();
       int hour = calendar.get(Calendar.HOUR);
       int minute = calendar.get(Calendar.MINUTE);
       int second = calendar.get(Calendar.SECOND);
   
       //画时针
       canvas.save();
       //画布的旋转,参数1:旋转的角度 2:围绕着旋转的点进行旋转的X轴坐标 3:Y轴坐标
       //第一个参数:就比如4:30 时针的偏移角度
       // 4*30=120表示四点的时候时针在钟表的这个角度的位置
       // 30分/60表示占据的百分比 然后再*30 就是三十分钟占一刻(30度)的多少角度
       canvas.rotate(hour * 30 + minute / 60 * 30, width, heigth);
       canvas.drawLine(width, heigth + 40, width, heigth - 140, hourPaint);
       canvas.restore();
   
       //画分针
       canvas.save();
       //分针每走一分都走6度
       canvas.rotate(minute * 6, width, heigth);
       canvas.drawLine(width, heigth + 30, width, heigth - 160, minPaint);
       canvas.restore();
   
       //画秒针
       canvas.save();
       //时针每走一分都走6度
       canvas.rotate(second * 6, width, heigth);
       canvas.drawLine(width, heigth + 20, width, heigth - 190, secPaint);
       canvas.restore();
   
       invalidate();//重复调用ondraw的方法,不断的绘制,使用时钟呈现出走动的效果
   }
   ```

具体使用：

```xml
<com.example.myemo.Myclock.MyQAnalogColck2
    android:id="@+id/myclock"
    android:layout_width="260dp"
    android:layout_height="270dp"
    android:layout_marginTop="72dp"
    app:layout_constraintLeft_toLeftOf="parent"
    app:layout_constraintRight_toRightOf="parent"
    app:layout_constraintTop_toTopOf="parent"  />
```

#### 关于自定义悬浮按钮（可拖拽移动） FloatingActionButton

```java
public class DragFloatActionButton extends FloatingActionButton {

    private int screenWidth;
    private int screenHeight;
    private int screenWidthHalf;
    private int statusHeight;
    private int virtualHeight;

    public DragFloatActionButton(Context context) {
        super(context); 
        init(); 
    }

    public DragFloatActionButton(Context context, AttributeSet attrs) {
        super(context, attrs);
        init();
    }

    public DragFloatActionButton(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        init();
    }

    private void init() {
        screenWidth = ScreenUtils.getScreenWidth(getContext());
        screenWidthHalf = screenWidth / 2;
        screenHeight = ScreenUtils.getScreenHeight(getContext());
        statusHeight = ScreenUtils.getStatusHeight(getContext());
        virtualHeight=ScreenUtils.getVirtualBarHeigh(getContext());
    }

    private int lastX;
    private int lastY;

    private boolean isDrag;  //判断拖拽的状态

    @Override
    public boolean onTouchEvent(MotionEvent event) {
        int rawX = (int) event.getRawX();
        int rawY = (int) event.getRawY();
        switch (event.getAction() & MotionEvent.ACTION_MASK) {
            case MotionEvent.ACTION_DOWN:
                isDrag = false;
                getParent().requestDisallowInterceptTouchEvent(true);
                lastX = rawX;
                lastY = rawY; 
                break;
            case MotionEvent.ACTION_MOVE:
                isDrag = true;
                //计算手指移动了多少
                int dx = rawX - lastX;
                int dy = rawY - lastY;
                //这里修复一些手机无法触发点击事件的问题
                int distance= (int) Math.sqrt(dx*dx+dy*dy);
//                Log.e("distance---->",distance+"");
                if(distance<3){//给个容错范围，不然有部分手机还是无法点击
                    isDrag=false;
                    break;
                }

                float x = getX() + dx;
                float y = getY() + dy;

                //检测是否到达边缘 左上右下
                x = x < 0 ? 0 : x > screenWidth - getWidth() ? screenWidth - getWidth() : x;
          
               if (y<0){
                   y=0;
               }
               if (y>screenHeight-statusHeight-getHeight()){
                   y=screenHeight-statusHeight-getHeight();
                }
                setX(x);
                setY(y);

                lastX = rawX;
                lastY = rawY;
 
                break;
            case MotionEvent.ACTION_UP:
                if (isDrag) {
                    //恢复按压效果
                    setPressed(false); 
                    if (rawX >= screenWidthHalf) {
                        animate().setInterpolator(new DecelerateInterpolator())
                                .setDuration(500)
                                .xBy(screenWidth - getWidth() - getX())
                                .start();
                    } else {
                        ObjectAnimator oa = ObjectAnimator.ofFloat(this, "x", getX(), 0);
                        oa.setInterpolator(new DecelerateInterpolator());
                        oa.setDuration(500);
                        oa.start();
                    }
                }
//                Log.e("up---->",isDrag+"");
                break;
        }
        //如果是拖拽则消耗事件，否则正常传递即可。
        return isDrag || super.onTouchEvent(event);

    }
}
```

```java
 
public class ScreenUtils {

    private ScreenUtils() { 
        throw new UnsupportedOperationException("cannot be instantiated");
    }

    /**
     * 获得屏幕高度
     *
     * @param context
     * @return
     */
    public static int getScreenWidth(Context context) {
        WindowManager wm = (WindowManager) context
                .getSystemService(Context.WINDOW_SERVICE);
        DisplayMetrics outMetrics = new DisplayMetrics();
        wm.getDefaultDisplay().getMetrics(outMetrics);
        return outMetrics.widthPixels;
    }

    /**
     * 获得屏幕宽度
     *
     * @param context
     * @return
     */
    public static int getScreenHeight(Context context) {
        WindowManager wm = (WindowManager) context
                .getSystemService(Context.WINDOW_SERVICE);
        DisplayMetrics outMetrics = new DisplayMetrics();
        wm.getDefaultDisplay().getMetrics(outMetrics);
        return outMetrics.heightPixels;
    }

    /**
     * 获得状态栏的高度
     *
     * @param context
     * @return
     */
    public static int getStatusHeight(Context context) {

        int statusHeight = -1;
        try {
            Class<?> clazz = Class.forName("com.android.internal.R$dimen");
            Object object = clazz.newInstance();
            int height = Integer.parseInt(clazz.getField("status_bar_height")
                    .get(object).toString());
            statusHeight = context.getResources().getDimensionPixelSize(height);
        } catch (Exception e) {
            e.printStackTrace();
        }
        return statusHeight;
    }

    /**
     * 获取虚拟功能键高度
     */
    public static int getVirtualBarHeigh(Context context) {
        int vh = 0;
        WindowManager windowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
        Display display = windowManager.getDefaultDisplay();
        DisplayMetrics dm = new DisplayMetrics();
        try {
            @SuppressWarnings("rawtypes")
            Class c = Class.forName("android.view.Display");
            @SuppressWarnings("unchecked")
            Method method = c.getMethod("getRealMetrics", DisplayMetrics.class);
            method.invoke(display, dm);
            vh = dm.heightPixels - windowManager.getDefaultDisplay().getHeight();
        } catch (Exception e) {
            e.printStackTrace();
        }
        return vh;
    }

    public static int getVirtualBarHeigh(Activity activity) {
        int titleHeight = 0;
        Rect frame = new Rect();
        activity.getWindow().getDecorView().getWindowVisibleDisplayFrame(frame);
        int statusHeight = frame.top;
        titleHeight = activity.getWindow().findViewById(Window.ID_ANDROID_CONTENT).getTop() - statusHeight;
        return titleHeight;
    }

}
```

#### 自定义进度条progressbar

```java
public class Myprogressbar extends ProgressBar {
    /**
     * 定义一个画笔
     */
    protected Paint mPaint = new Paint();
    /**
     * 设置默认的显示进度文字的颜色
     * 设置显示默认的显示进度的文字的大小
     * 设置默认的绘制进度条的高度
     * 设置默认的绘制进度条颜色
     * 未加载进度条的颜色
     * 绘制进度条的实际宽度
     */
    protected int mTextColor = 0xff253688; 
    protected int mTextSize = sp2px(16); 
    protected int mProgressBarHeight = dp2px(20); 
    protected int mBarColor = 0xffffcc00; 
    protected int mUnBarColor = 0xffe6e6e6; 
    protected int mRealWidth;

    public Myprogressbar(Context context, AttributeSet attrs) {
        super(context, attrs);
//        Log.v("myProgressbar","自定义导航栏调用1");
    } 
    public Myprogressbar(Context context, AttributeSet attrs,int defStyle) {
        super(context, attrs, defStyle);
//        Log.v("myProgressbar","自定义导航栏调用2");
    }

    @Override
    protected synchronized void onDraw(Canvas canvas) {

        canvas.save();
        /**
         * 定义画笔的初始位置
         */
        canvas.translate(getPaddingLeft(), getHeight() / 2); 
        /**
         * 计算加载进度的比例
         */
        float radio = getProgress() * 1.0f / getMax();
        /**
         * 计算已加载的进度
         */
        float progressPosX = (int) (mRealWidth * radio);
        /**
         * 定义进度上显示的文字信息
         */
        DecimalFormat df = new DecimalFormat("#.0");
        String text =  df.format(getProgress()/2) + "%";

        /**
         * 获取绘制文字的宽与高
         */ 
        mPaint.setTextSize(mTextSize);
        float textWidth = mPaint.measureText(text);//该方法并未真实的获取到字符串宽度，应该设置当前文字字体大小，才能正确获取
        float textHeight = (mPaint.descent() + mPaint.ascent())/2;
//        Log.v("masas",text+"    "+textWidth);
        /**
         * 判断绘制
         */
        if (progressPosX + textWidth > mRealWidth) {
            progressPosX = mRealWidth - textWidth;
        } 
        /**
         * 绘制已加载的进度
         */ 
        mPaint.setColor(mBarColor);
        mPaint.setStrokeWidth(mProgressBarHeight);
        canvas.drawLine(0, 0, progressPosX, 0, mPaint); 

//        Log.v("asds",progressPosX+""); 
        mPaint.setColor(mTextColor);

        canvas.drawText(text,progressPosX, -textHeight, mPaint);

        /**
         * 绘制未加载的进度
         */
        float start = progressPosX + textWidth;
        mPaint.setColor(mUnBarColor);
        mPaint.setStrokeWidth(mProgressBarHeight);
        canvas.drawLine(start, 0, mRealWidth, 0, mPaint);
//        Log.v("asds",start+"");
        /**
         * 绘制加载显示的文字
         */ 
        canvas.restore(); 
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        mRealWidth = w-getPaddingLeft()-getPaddingRight();
        Log.v("Myprogressbar","当前宽度："+ mRealWidth);
    }
    /**
     * dp 2 px
     *
     * @param dpVal
     */
    protected int dp2px(int dpVal) {
        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
                dpVal, getResources().getDisplayMetrics());
    }

    /**
     * sp 2 px
     *
     * @param spVal
     * @return
     */
    protected int sp2px(int spVal) {
        return (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,
                spVal, getResources().getDisplayMetrics());

    }

    /**
     * 设置已绘制的进度条的颜色
     *
     * @param mBarColor
     */
    public void setmBarColor(int mBarColor) {
        this.mBarColor = mBarColor;
    }

    /**
     * 设置过度条的高度
     *
     * @param mProgressBarHeight
     */
    public void setmProgressBarHeight(int mProgressBarHeight) {
        this.mProgressBarHeight = mProgressBarHeight;
    }

    /**
     * 设置指示进度条的显示文字的颜色
     *
     * @param mTextColor
     */
    public void setmTextColor(int mTextColor) {
        this.mTextColor = mTextColor;
    }

    /**
     * 设置指示进度条进度的显示文字的颜色
     *
     * @param mTextSize
     */
    public void setmTextSize(int mTextSize) {
        this.mTextSize = mTextSize;
    }

    /**
     * 设置未加载进度条处的进度颜色
     *
     * @param mUnBarColor
     */
    public void setmUnBarColor(int mUnBarColor) {
        this.mUnBarColor = mUnBarColor;
    } 
    private  void  initFunction(){

        mPaint.setTextSize(mTextSize); 

    }
    @Override
    protected synchronized void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { 
        /**
         * 1.static int getMode(int measureSpec):根据提供的测量值(格式)提取模式(上述三个模式之一)
         * 2.static int getSize(int measureSpec):根据提供的测量值(格式)提取大小值(这个大小也就是我们通常所说的大小)
         * 3.static int makeMeasureSpec(int size,int mode):根据提供的大小值和模式创建一个测量值(格式)
         */ 
        /**
         * 三种测量模式
         * UNSPECIFIED：父布局没有给子布局任何限制，子布局可以任意大小。
         * EXACTLY：父布局决定子布局的确切大小。不论子布局多大，它都必须限制在这个界限里。
         * AT_MOST：子布局可以根据自己的大小选择任意大小。
         */ 
        /**
         * 获取测量宽度大小
         */
        int width = MeasureSpec.getSize(widthMeasureSpec);
        /**
         * 对高度进度测量
         */
        int height = 0; 
        /**
         * 获取高度的测量模式
         */
        int specMode = MeasureSpec.getMode(heightMeasureSpec);
        /**
         * 获取测量高度的大小
         */
        int specSize = MeasureSpec.getSize(heightMeasureSpec);
        /**
         * 判断如果是非精准度的，那么就进行测量大小的重新设定
         */
        if (specMode == MeasureSpec.EXACTLY) {
            height = specSize;
        } else {
            /**
             * 获取显示加载进度的显示文本的宽度与高度
             */
            float textHeight = (mPaint.descent() - mPaint.ascent());
            /**
             * 计算测量的高度
             */
            height = (int) (getPaddingTop() + getPaddingBottom() + Math.max(
                    mProgressBarHeight, Math.abs(textHeight)));
            if (specMode == MeasureSpec.AT_MOST) {
                height = Math.min(height, specSize);
            }
        }
        
        setMeasuredDimension(width, height);
 
        mRealWidth = getMeasuredWidth() - getPaddingRight() - getPaddingLeft();
    }

    /**
     * 获取自定义属性操作
     * @param context
     * @param attrs
     * @param defStyle
     */
    private void initFunction(Context context, AttributeSet attrs, int defStyle) {

        final TypedArray attributes = getContext().obtainStyledAttributes(
                attrs, R.styleable.Myprogressbar);

        mTextColor = attributes.getColor(R.styleable.Myprogressbar_textProColor, 0xffabc00);
    }
}
```

##### 在MainActivity中使用：

```java
private static Myprogressbar mpbar; 
 protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState); 
        setContentView(R.layout.saol_main);
        mpbar = (Myprogressbar) findViewById(R.id.progress_bar);
        mpbar.setMax(ROW*COL);  //设置最大值 
        //定义子线程
        handler.sendEmptyMessage(1001); 
    }
    //
    private Handler handler = new Handler() {
        @Override
        public void handleMessage(Message msg) {
            super.handleMessage(msg); 
            if (msg.what == 1001) {
                mpbar.setmBarColor(randomColor());
                mpbar.setProgress(VOPEN_count);  // 设置进度条的具体值
                if (VOPEN_count > ROW*COL-LEICOUNT) {
                    handler.removeMessages(1001);  // 根据具体情况修改进度值
                }
                if (VOPEN_count < ROW*COL-LEICOUNT) { 
                    handler.sendEmptyMessageDelayed(1001, 1000);
                }
            }
        }
    };
 // 随机设置精度条的颜色
    public  int randomColor(){
        Random random = new Random();   //如果值太大，会偏白，太小则会偏黑，所以需要对颜色的值进行范围限定
        int red = random.nextInt(150)+50;//50-199
        int green = random.nextInt(150)+50;//50-199
        int blue = random.nextInt(150)+50;//50-199
        return Color.rgb(red, green, blue);//根据rgb混合生成一种新的颜色
    }

```

#### onpopupwindow弹出悬浮窗口

```java
//调用该方法即可
public void showPopupWindow() {
        View contentView = LayoutInflater.from(LogEditActivity.this).inflate(R.layout.loglist_card, null);
        PopupWindow mPopWindow = new PopupWindow(contentView, ActionBar.LayoutParams.MATCH_PARENT, ActionBar.LayoutParams.WRAP_CONTENT, true);
        mPopWindow.setContentView(contentView);

        //显示PopupWindow
        View rootview = LayoutInflater.from(LogEditActivity.this).inflate(R.layout.loglist_edit, null);
        mPopWindow.showAtLocation(rootview, Gravity.BOTTOM, 0, 0); 
    /* 若要添加监听事件即 加载对应插件
    *  Button btn = contentView.findviewByid(R.id.xx);
    *  btn.setOnclickListener(new(....)) 即可
    */
    } 
```



#### RecyclerView的适配器加载

```java
class MyCardAdtapter  extends RecyclerView.Adapter<MyCardAdtapter.VH>{

        @NonNull
        @Override
        public  VH onCreateViewHolder(@NonNull ViewGroup parent, int viewType) {
//        View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.loglist_item,parent,false);
            View view = new Button(parent.getContext());
            return new  VH(view);
        }
        @Override
        public void onBindViewHolder(@NonNull  VH holder, int position) {
            holder.btn.setText("(●'◡'●)");
            holder.btn.setTextColor(Color.parseColor(stylelist.get( position).getTextcolor()));
            holder.btn.setBackgroundColor(Color.parseColor(stylelist.get( position).getBackground()));
            holder.itemView.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    holder.btn.setText("(●'◡'●)");
                    int finalposition = holder.getAdapterPosition();
                    Style finalStyle = stylelist.get(finalposition);
                    logstyle = finalStyle;
                    logedt.setBackgroundColor(Color.parseColor(finalStyle.getBackground()));
                    logedt.setTextColor(Color.parseColor(finalStyle.getTextcolor()));
                }
            });
        }

        @Override
        public int getItemCount() {
            return stylelist.size();
        }

        public  class VH extends RecyclerView.ViewHolder{
            public final Button btn;
            public VH(View v) {
                super(v);
                btn = (Button) v;
            }
        }
    }
```

若要添加监听事件 也可 在适配器类中定义一个监听接口

```java
public MyItemClickListener mItemClickListener;

  // recycleview  item的 监听
    /**
     * 创建一个回调接口
     */
    public interface MyItemClickListener {
        void onItemClick(View view, int position);
    }

    /**
     * 在activity里面adapter就是调用的这个方法,将点击事件监听传递过来,并赋值给全局的监听
     *
     * @param myItemClickListener
     */
    public void setItemClickListener(MyItemClickListener myItemClickListener) {
        this.mItemClickListener = myItemClickListener;
    }

///////////////////////////////////////////////////////////

//使用
 MyCardAdtapter mycardAdtapter = new MyCardAdtapter();
        recyclerview.setAdapter(mycardAdtapter);
mycardAdapter.setonclicklistener(new  MyCardAdtapte.mItemClickListener(//这里实现具体的监听方法));
```

#### Toolbar + menu

1. 修改该Activity的style

   ```xml
   <style name="Theme.toolbar" parent="Theme.AppCompat.Light.NoActionBar">
       <!-- Customize your theme here. -->
       <item name="colorPrimary">@color/transparency</item>
       <item name="colorPrimaryDark">@color/transparency</item>
       <item name="colorAccent">@color/transparency</item>
       <!-- Status bar color. 显示时间导航等信息-->
       <item name="android:statusBarColor" tools:targetApi="l">?attr/colorPrimaryVariant</item>
       <item name="alertDialogTheme">@style/Theme.AppCompat.Light.Dialog.Alert.Self</item>
   </style>
   ```

   **应用**

```xml
<activity
    android:name=".ui.main.LogActivity"
    android:exported="true"
    android:theme="@style/Theme.toolbar">
    <intent-filter>
        <action android:name="android.intent.action.SHOW_APP_INFO" />

        <category android:name="android.intent.category.LAUNCHER" />
    </intent-filter>
</activity>
```

  2.在Activity的layout.xml文件中使用Toolbar 控件

```xml
<androidx.appcompat.widget.Toolbar
    android:id="@+id/loglist_toolbar"
    android:layout_width="match_parent"
    android:layout_height="?actionBarSize"
    android:background="#32DDC3A9"
    android:theme="@style/Theme.toolbar"
    app:title="每日一记" />
```

3.添加menu

在Activity 中定义以下方法 ，并且在这之前还需要定义 menu.xml 文件（  比如这个   R.menu.loglistmain ） 

```java
@Override
public boolean onCreateOptionsMenu(Menu menu) {
    MenuInflater inflater = getMenuInflater();
    if(inflater!=null){
        inflater.inflate(R.menu.loglistmain, menu);
    }else{
        Log.v("LoglistActivity","菜单加载失败");
    }
    return true;
}
// 菜单项的监听事件
 @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.menu_delete: Log.v("Logli34vity","菜单加载失败");
//                Delete_log();
                break;
            case R.id.menu_cancel:
//                Cancel_checked();
                break;
            default:
                break;
        }
    return super.onOptionsItemSelected(item);
    }
```

若上面的监听方法无效的话，采用以下方法：

```java
Toolbar toolbar = findViewById(R.id.loglist_toolbar);
        toolbar.inflateMenu(R.menu.loglistmain);
        toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() {
            @Override
            public boolean onMenuItemClick(MenuItem item) {
                switch (item.getItemId()) {
                    case R.id.menu_deleteAll: 
                        // 创建弹出框 询问  
                        AlertDialog alertDialog = new AlertDialog.Builder(LogActivity.this)
                                .setTitle("真的要将所有日志都清空吗？")
                                .setPositiveButton("真的", new DialogInterface.OnClickListener() {
                                    @Override
                                    public void onClick(DialogInterface dialog, int which) {
                                        Delete_logALL();
                                    }
                                })
                                .setNegativeButton("不要", null)
                                .create();
                        alertDialog.show();
                        // 显示弹出框 不显示按钮文字 出现问题 调整style 方法无效
                        Button btnPos =  alertDialog.getButton(DialogInterface.BUTTON_POSITIVE);
                        Button btnNeg =  alertDialog.getButton(DialogInterface.BUTTON_NEGATIVE);
                        btnPos.setTextColor(Color.BLUE);
                        btnNeg.setTextColor(Color.RED);
                        break;
                    case R.id.menu_change1:
                        if(listclumn == 1){
                            item.setTitle("列表模式");  // 根据菜单选项 当用户点击菜单时 切换模式，菜单选项更换为另外一个
                            listclumn = 2;

                        }else if(listclumn == 2){
                            item.setTitle("宫格模式");
                            listclumn = 1;
                        }
                       
                        break;
                    default:
                        break;
                }
                return true;
            }
        });
```

#### Imageview 加载动态gif图片

方法1：

```java
 public class MyGifView extends View {

    private long movieStart;

    private Movie movie;

    //此处必须重写该构造方法

    @SuppressLint("ResourceType")
    public MyGifView(Context context, AttributeSet attributeSet) {

        super(context,attributeSet);

//以文件流（InputStream）读取进gif图片资源

        movie=Movie.decodeStream(getResources().openRawResource(R.drawable.show1));

    }



    @Override

    protected void onDraw(Canvas canvas) {

        long curTime=android.os.SystemClock.uptimeMillis();

//第一次播放

        if (movieStart == 0) {

            movieStart = curTime;

        }

        if (movie != null) {

            int duraction = movie.duration();
            int height = canvas.getHeight();

            int relTime = (int) ((curTime-movieStart)%duraction);

            movie.setTime(relTime);

            movie.draw(canvas, 0, height-300);

        //强制重绘

            invalidate();

        }

        super.onDraw(canvas);

    }

}
```

方法2：

采用glide库

1. 添加配置

   ```java
   implementation 'com.github.bumptech.glide:glide:4.12.0'
   ```

   2.

```java
ImageView gifView1 =  findViewById(R.id.restartbtnnum);
Glide.with(this).load(R.drawable.s5).into(gifView1);
gifView1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        gmview.startGame();
    }
});
```

#### 自定义Dialog

![image-20220129225110944](D:\Typoramarkdown学习编辑\img\image-20220129225110944.png)

```java
private class LoadingDialog {
        public   void LDialog(Context context, int type) {
            androidx.appcompat.app.AlertDialog.Builder builder = new androidx.appcompat.app.AlertDialog.Builder(context);
            View contenView = LayoutInflater.from(context).inflate(R.layout.saolfall_dialog_show, null);
            builder.setView(contenView);
//                    创建显示dialog 自定义界面显示
            final AlertDialog dialog = builder.create();
            Window dialogWindow = dialog.getWindow();
            WindowManager.LayoutParams lp = dialogWindow.getAttributes();
            dialogWindow.setGravity(Gravity.CENTER);
            ImageView gifView1 = contenView.findViewById(R.id.im1);
            TextView textView = contenView.findViewById(R.id.s_tv);
            switch (type){
                case 0:
                    gifView1.setImageResource(R.drawable.saolei_df);
                    textView.setText("你爆雷了！");
                    break;
                case 1:
                    gifView1.setImageResource(R.drawable.saolei_dp);
                    textView.setText("游戏完成！");
                    break;
                default:
                    break;
            }
            Button restartbtn = contenView.findViewById(R.id.saolei_restart);
            restartbtn.setOnClickListener(new View.OnClickListener() {
                @Override
                public void onClick(View v) {
                    startGame();
                    dialog.dismiss();
                }
            });
            dialog.getWindow().setBackgroundDrawableResource(android.R.color.transparent);
            WindowManager m = dialogWindow.getWindowManager();
            dialog.show();

            Display d = m.getDefaultDisplay(); // 获取屏幕宽、高用
            WindowManager.LayoutParams p = dialogWindow.getAttributes(); // 获取对话框当前的参数值
            p.height = (int) (d.getHeight() * 0.35); // 高度设置为屏幕的0.35
            p.width = (int) (d.getWidth() * 0.6); // 宽度设置为屏幕的0.60
            dialog.getWindow().setAttributes(p);//设置大小

            dialog.setOnKeyListener(new DialogInterface.OnKeyListener() {
                @Override
                public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
                    boolean click = false;
                    if (keyCode == KeyEvent.KEYCODE_BACK) {
                        dialog.dismiss();

                        click = true;
                    }
                    return click;
                }
            });

        }

    }
```

####  viewpager+tablayout

```java
private void initView(int position) {
    mTabTitles[0] = "2048";
    mTabTitles[1] = "拼图";
    mTabTitles[2] = "扫雷";
    tablayout.setTabMode(TabLayout.MODE_FIXED);
    //设置tablayout距离上下左右的距离
    //tab_title.setPadding(20,20,20,20);
    mfragmentlist = new ArrayList<>();
    mfragmentlist.add(new TZ_Fragment());
    mfragmentlist.add(new Chi_Fragment());
    mfragmentlist.add(new Saol_Fragment());
    MyAdapter  Adapter = new MyAdapter(getSupportFragmentManager(),this);
    viewpager.setAdapter( Adapter);

    //将ViewPager和TabLayout绑定
    tablayout.setupWithViewPager(viewpager);
    viewpager.setCurrentItem(position);   //设置当前游戏位置
 
    //设置自定义视图
    for (int i = 0; i < tablayout.getTabCount(); i++) {
        TabLayout.Tab tab = tablayout.getTabAt(i);
        tab.setCustomView( Adapter.getTabView(i));
    }

}
//监听返回键 实现返回游戏界面 homeActivity
@Override
public void onBackPressed() {
    super.onBackPressed();
    finish();

}
class MyAdapter extends FragmentPagerAdapter {

    private Context context;

    public MyAdapter(FragmentManager fm, Context context) {
        super(fm);
        this.context = context;
    }

    @Override
    public Fragment getItem(int position) {
        return mfragmentlist.get(position);
    }

    @Override
    public int getCount() {
        return mfragmentlist.size();
    }

    /**
     * 自定义方法，提供自定义Tab
     *
     * @param position 位置
     * @return 返回Tab的View
     */
    public View getTabView(int position) {
        View v = LayoutInflater.from(context).inflate(R.layout.zfragment_tab, null);
        TextView textView = (TextView) v.findViewById(R.id.tv_title);
        ImageView imageView = (ImageView) v.findViewById(R.id.iv_icon);
        textView.setText(mTabTitles[position]);
        imageView.setImageResource(mImages[position]);
        //添加一行，设置颜色
        textView.setTextColor(tablayout.getTabTextColors());//
        return v;
    }
}
```

### android如何让布局保持位于键盘上方（一直在键盘上面）

在实际项目中，肯定会有输入数据的情况，这样就会用到键盘。

但是键盘弹起必然会遮盖掉屏幕下半部分的布局。

比如说一个登陆界面，账号、密码的输入框在最上面，登陆、取消按钮在下方，当用户点击输入账号时，就有可能把最底下的按钮遮住，甚至会把密码框也遮住导致不能直接切换到密码输入框。这样用户使用起来是不是特别别扭呢？

解决方法：

在manifest文件中的activity标签中修改android:windowSoftInputMode属性
属性参数：

各值的含义：
【A】stateUnspecified：软键盘的状态并没有指定，系统将选择一个合适的状态或依赖于主题的设置
【B】stateUnchanged：当这个activity出现时，软键盘将一直保持在上一个activity里的状态，无论是隐藏还是显示
【C】stateHidden：用户选择activity时，软键盘总是被隐藏
【D】stateAlwaysHidden：当该Activity主窗口获取焦点时，软键盘也总是被隐藏的
【E】stateVisible：软键盘通常是可见的
【F】stateAlwaysVisible：用户选择activity时，软键盘总是显示的状态
【G】adjustUnspecified：默认设置，通常由系统自行决定是隐藏还是显示
【H】adjustResize：该Activity总是调整屏幕的大小以便留出软键盘的空间
【I 】adjustPan：当前窗口的内容将自动移动以便当前焦点从不被键盘覆盖和用户能总是看到输入内容的部分

还有一种情况。你单纯想将原本靠在屏幕底部的按钮、文字、图片、布局之类的控件不被键盘遮住，想它们跟着键盘上下移动。

解决方法：

其实很简单。xml中给控件添加属性alignParentBottom = true；在显示键盘和隐藏键盘方法中添加方法view.requestLayout()；

这样view就会跟着键盘移动了。

 

### 在弹出键盘的同时，在键盘上添加视图

步骤：

- 在init() 方法中添加监听

```
//给软键盘添加监听事件，监听软键盘的高度，添加布局，在键盘上方添加视图
        View decorView = getWindow().getDecorView();
        View contentView = findViewById(Window.ID_ANDROID_CONTENT);
        decorView.getViewTreeObserver().addOnGlobalLayoutListener(getGlobalLayoutListener(decorView, contentView));
```

- 实现监听方法，可将视图的显示单独定义一个方法，实现视图的显示

  ```java
   // 设置监听器，显示软键盘以上的视图
      private ViewTreeObserver.OnGlobalLayoutListener getGlobalLayoutListener(final View decorView, final View contentView) {
          return new ViewTreeObserver.OnGlobalLayoutListener() {
              @Override
              public void onGlobalLayout() {
                  Rect r = new Rect();
                  //获取当前界面可视部分
                  decorView.getWindowVisibleDisplayFrame(r);
                  //获取屏幕的高度
                  int height = decorView.getContext().getResources().getDisplayMetrics().heightPixels;
                  int diff = height - r.bottom;
  
                  if (diff != 0) {
                      if (contentView.getPaddingBottom() != diff) {
                          showAViewOverKeyBoard(diff);
                      }
                  }  else{
                          showAViewOverKeyBoard(diff);
                  }
  //                Log.d("Keyboard Size", "Size: " + diff );
              }
          };
      }
  /*
  *
  *
  * 在软键盘上添加视图，实现编辑文本的功能
  *
   */
      private View overkeyView = null;
      private RelativeLayout rl_root = null ;
      private  boolean boldfg = false;
      private void showAViewOverKeyBoard(int heightDifference) {
          if (heightDifference > 0) {//显示
              if (overkeyView == null) {//第一次显示的时候创建  只创建一次
                  overkeyView = View.inflate(this, R.layout.overkeybord, null);
                  RelativeLayout.LayoutParams loginlayoutParams = new RelativeLayout.LayoutParams(-1, -2);
                  loginlayoutParams.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);
  //                loginlayoutParams.bottomMargin = heightDifference;
  //                \\ 这里在主界面将edittext 控件设置为scrollView 包含的布局之后 页面所获取的内容在键盘之上，所以这里不需要添加额外的高度，相反要避免overkeyview 的布局 遮盖编辑框
  
   /*…………****************** 在软键盘上添加视图，实现编辑文本的功能******************                 */
                  // 1.点击实现文本加粗按钮
                 ImageButton  boldbtn = overkeyView.findViewById(R.id.boldbtn);
                  boldbtn.setOnClickListener(new View.OnClickListener() {
                      @Override
                      public void onClick(View v) {
                          // 设置动态textStyle的方法，但只能单一的显示该风格，不能灵活改变
  //                        logedt.setTypeface(null, Typeface.BOLD);
  //                        logedt.invalidate();
  //                        String textsource = "修改TextView中部分文字的<font color='#ff0000'><big>大</big><small>小</small></font>和<font color='#00ff00'>颜色</font>，展示多彩效果！";
                         if(boldfg == false){
                             boldbtn.setBackgroundResource(R.mipmap.bold2);
                             textSource.append("<font><b></b></font>");
                             boldfg = true;  //已经加粗
                             count++;
                         }else{
                             boldbtn.setBackgroundResource(R.mipmap.bold1);
                             boldfg = false;
  
                         }
  
  //                        String textSource = "<font><bold>";
  //                        int index = logedt.getSelectionStart(); //获取光标所在位置
  //                        Editable edit_text = logedt.getEditableText();
  //                        if(index <0 || index >= edit_text.length()){
  //                            edit_text.append(Html.fromHtml( textsource));
  //                        }else{
  //                            edit_text.insert(index, Html.fromHtml( textsource));
  //                        }
                      }
  
                  });
                  // 2.点击添加#字符号
                  ImageButton hashbtn = overkeyView.findViewById(R.id.hashbtn);
                  hashbtn.setOnClickListener(new View.OnClickListener() {
                      @Override
                      public void onClick(View v) {
                          int index = logedt.getSelectionStart();
                          Editable edit_text = logedt.getEditableText();
                          edit_text.append("#");
                      }
                  });
  //            3.点击添加照片,弹出对话框
                  ImageButton picturebtn = overkeyView.findViewById(R.id.picturebtn);
                  picturebtn.setOnClickListener(new View.OnClickListener() {
                      @Override
                      public void onClick(View v) {
                          final CharSequence[] items = {"手机相册", "相机拍摄"};
                          AlertDialog dlg = new AlertDialog.Builder(LogEditActivity.this).setTitle("选择图片").setItems(items,
                                  new DialogInterface.OnClickListener() {
                                      public void onClick(DialogInterface dialog, int item) {
                                          //这里item是根据选择的方式,
                                          //在items数组里面定义了两种方式, 拍照的下标为1所以就调用拍照方法
                                          if (item == 1) {
                                              Intent getImageByCamera = new Intent("android.media.action.IMAGE_CAPTURE");
                                              startActivityForResult(getImageByCamera, CAMERA_SUCCESS);
                                          } else {
                                              Intent getImage = new Intent(Intent.ACTION_GET_CONTENT);
                                              getImage.addCategory(Intent.CATEGORY_OPENABLE);
                                              getImage.setType("image/*");
                                              startActivityForResult(getImage, PHOTO_SUCCESS);
                                          }
                                      }
                                  }).create();
                          dlg.show();
                      }
                  });
                  rl_root.addView(overkeyView,loginlayoutParams );
              }
              overkeyView.setVisibility(View.VISIBLE);
          } else {//隐藏
              if (overkeyView != null) {
                  overkeyView.setVisibility(View.GONE);
              }
          }
      }
      /*…………****************** 在软键盘上添加视图，实现编辑文本的功能******************
       */
  ```

  

### 临时

```
    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {

        ContentResolver resolver = getContentResolver();
        if (resultCode == RESULT_OK) {
            switch (requestCode) {
                case PHOTO_SUCCESS:
                    //获得图片的uri
                    Uri originalUri = intent.getData();
                    Bitmap bitmap = null;
                    try {
                        Bitmap originalBitmap = BitmapFactory.decodeStream(resolver.openInputStream(originalUri));
                        int height = (int) (originalBitmap.getHeight()*0.6);
                        int width = (int) (originalBitmap.getWidth()*0.6);  //压缩大小
                        bitmap = resizeImage(originalBitmap, width, height);
                    } catch (FileNotFoundException e) {
                        e.printStackTrace();
                    }
                    if(bitmap != null){
                        //根据Bitmap对象创建ImageSpan对象
                        ImageSpan imageSpan = new ImageSpan(LogEditActivity.this, bitmap);
                        //创建一个SpannableString对象，以便插入用ImageSpan对象封装的图像
                        SpannableString spannableString = new SpannableString((CharSequence) originalUri);
                        //  用ImageSpan对象替换face
                        spannableString.setSpan(imageSpan, 0, originalUri.toString().length()+1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                        //将选择的图片追加到EditText中光标所在位置
                        int index = logedt.getSelectionStart(); //获取光标所在位置
                        Editable edit_text = logedt.getEditableText();
                        if(index <0 || index >= edit_text.length()){
                            edit_text.append(spannableString);
                        }else{
                            edit_text.insert(index, spannableString);
                        }
                    }else{
                        Toast.makeText(LogEditActivity.this, "获取图片失败", Toast.LENGTH_SHORT).show();
                    }
                    break;
                case CAMERA_SUCCESS:
                    Bundle extras = intent.getExtras();
                    Bitmap originalBitmap1 = (Bitmap) extras.get("data");
                    int height = (int) (originalBitmap1.getHeight()*0.6);
                    int width = (int) (originalBitmap1.getWidth()*0.6);  //压缩大小
                    if(originalBitmap1 != null){
                        bitmap = resizeImage(originalBitmap1, width , height );
                        //根据Bitmap对象创建ImageSpan对象
                        ImageSpan imageSpan = new ImageSpan(LogEditActivity.this, bitmap);
                        String name =Calendar.getInstance(Locale.CHINA).getTimeInMillis() + ".jpg";
                        //创建一个SpannableString对象，以便插入用ImageSpan对象封装的图像
                        SpannableString spannableString = new SpannableString(name);
                        //  用ImageSpan对象替换face
                        spannableString.setSpan(imageSpan, 0, name.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
                        //将选择的图片追加到EditText中光标所在位置
                        int index = logedt.getSelectionStart(); //获取光标所在位置
                        Editable edit_text = logedt.getEditableText();
                        if(index <0 || index >= edit_text.length()){
                            edit_text.append(spannableString);
                        }else{
                            edit_text.insert(index, spannableString);
                        }
                    }else{
                        Toast.makeText(LogEditActivity.this, "获取图片失败", Toast.LENGTH_SHORT).show();
                    }
                    break;
                default:
                    break;
            }
        }
    }
    /**
     * 图片缩放
     * @param originalBitmap 原始的Bitmap
     * @param newWidth 自定义宽度
     * @return 缩放后的Bitmap
     */
    private Bitmap resizeImage(Bitmap originalBitmap, int newWidth, int newHeight){
        int width = originalBitmap.getWidth();
        int height = originalBitmap.getHeight();
        //定义欲转换成的宽、高
//            int newWidth = 200;
//            int newHeight = 200;
        //计算宽、高缩放率
        float scanleWidth = (float)newWidth/width;
        float scanleHeight = (float)newHeight/height;
        //创建操作图片用的matrix对象 Matrix
        Matrix matrix = new Matrix();
        // 缩放图片动作
        matrix.postScale(scanleWidth,scanleHeight);
        //旋转图片 动作
        //matrix.postRotate(45);
        // 创建新的图片Bitmap
        Bitmap resizedBitmap = Bitmap.createBitmap(originalBitmap,0,0,width,height,matrix,true);
        return resizedBitmap;
    }

    //+_+_+_+_+_+_+_+_+_+_+_+_+定义一个解析图片的方法+_+_+_+_+_+_+_+_
    public CharSequence analyzeImage(String content){
        String my_content=content;
        SpannableString span_str=new SpannableString(content);
        Pattern p=Pattern.compile("767867");
        Matcher m=p.matcher(content);
        while(m.find()){
            String mypath=m.group();
            Toast.makeText(this, m.group(), Toast.LENGTH_SHORT);
            Bitmap bitmap=BitmapFactory.decodeFile(mypath);
            Bitmap rbitmap=resizeImage(bitmap, 300, 300);
            ImageSpan span=new ImageSpan(this,rbitmap);
            span_str.setSpan(span, m.start(), m.end(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
        }
        return span_str;
    }
    //+_+_+_+_+_+_+_+_+_+_+_+_+定义一个解析图片的方法+_+_+_+_+_+_+_+_//
```

```
logimgbtn.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        final CharSequence[] items = {"手机相册", "相机拍摄"};
        AlertDialog dlg = new AlertDialog.Builder(LogEditActivity.this).setTitle("选择图片").setItems(items,
                new DialogInterface.OnClickListener() {
                    public void onClick(DialogInterface dialog, int item) {
                        //这里item是根据选择的方式,
                        //在items数组里面定义了两种方式, 拍照的下标为1所以就调用拍照方法
                        if (item == 1) {
                            Intent getImageByCamera = new Intent("android.media.action.IMAGE_CAPTURE");
                            startActivityForResult(getImageByCamera, CAMERA_SUCCESS);
                        } else {
                            Intent getImage = new Intent(Intent.ACTION_GET_CONTENT);
                            getImage.addCategory(Intent.CATEGORY_OPENABLE);
                            getImage.setType("image/*");
                            startActivityForResult(getImage, PHOTO_SUCCESS);
                        }
                    }
                }).create();
        dlg.show();
    }
});
```
